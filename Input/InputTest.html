<!DOCTYPE html>
<html>

<head>
    <title>Input Test</title>
</head>

<body>
    <math-field id="test">(\forall x) (Px \lor\lnot Qxc_1 \rightarrow \exists y (Rxy \land Sy))</math-field>
    <p>$$(\forall x) (P(x) \lor\lnot Q(x, c_1) \rightarrow (\exists y) (R(x,y) \land S(y)))$$<br />
        <span id="out">(∀x)(P(x) or not Q(x,c_1)→(∃y)(R(x,y) and S(y)))</span>
    </p>

    <script type="module">
        const mf = document.getElementById("test");
        const out = document.getElementById("out");

        window.addEventListener("DOMContentLoaded", () =>
            import("//unpkg.com/mathlive?module").then((mathlive) => {
                out.innerText = "$$" + render(parse(mf.getValue("ascii-math"))) + "$$";
                mathlive.renderMathInDocument();
                mf.inlineShortcuts = {
                    ...mf.inlineShortcuts,
                    "->": "\\rightarrow",
                    "vv": "\\lor",
                    "^^": "\\land",
                    "!!": "\\lnot",
                    "not": "\\lnot",
                    "!EE": "\\lnot\\exists",
                    "!exists": "\\lnot\\exists",
                    "implies": "\\rightarrow",
                    "→": "\\rightarrow",
                    "FF": "\\bot",
                };
                console.log(mf.inlineShortcuts);
            })
        );

        mf.addEventListener("change", (event) => {
            import("//unpkg.com/mathlive?module").then((mathlive) => {
                console.log(mf.getValue("ascii-math"));
                out.innerText = "$$" + render(parse(mf.getValue("ascii-math"))) + "$$";
                mathlive.renderMathInElement(out);
            })
        });

        function parse(s) {
            let errors = [];
            let [e, rest] = parseExpr(s.trim(), errors);
            if (rest !== "") {
                errors.push("Excess input '" + rest + "'");
            }
            console.log(errors);
            if (errors.length === 0) {
                return e;
            } else {
                return "E"; // TODO
            }
        }

        function parseExpr(s, errors) {
            let [e1, rest] = parseOExpr(s, errors);
            if (rest.startsWith("→")) {
                let [e2, rest2] = parseExpr(rest.substring(1).trim(), errors);
                e1 = { op: "implies", e1, e2 };
                rest = rest2;
            } else if (rest.startsWith("->")) {
                let [e2, rest2] = parseExpr(rest.substring(2).trim(), errors);
                e1 = { op: "implies", e1, e2 };
                rest = rest2;
            }
            return [e1, rest.trim()];
        }

        function parseOExpr(s, errors) {
            let [e1, rest] = parseAExpr(s, errors);
            while (rest.startsWith("or")) {
                let [e2, rest2] = parseAExpr(rest.substring(2).trim(), errors);
                e1 = { op: "or", e1, e2 };
                rest = rest2;
            }
            return [e1, rest.trim()];
        }

        function parseAExpr(s, errors) {
            let [e1, rest] = parseQExpr(s, errors);
            while (rest.startsWith("and")) {
                let [e2, rest2] = parseQExpr(rest.substring(3).trim(), errors);
                e1 = { op: "and", e1, e2 };
                rest = rest2;
            }
            return [e1, rest.trim()];
        }

        function parseQExpr(s, errors) {
            if (s.startsWith("∀")) {
                let [v, rest] = parseVar(s.substring(1).trim(), errors);
                let [e, rest2] = parseQExpr(rest, errors);
                return [{ op: "all", v, e }, rest2];
            } else if (s.startsWith("∃")) {
                let [v, rest] = parseVar(s.substring(1).trim(), errors);
                let [e, rest2] = parseQExpr(rest, errors);
                return [{ op: "exists", v, e }, rest2];
            } else if (s.startsWith("(∀")) {
                let [v, rest] = parseVar(s.substring(2).trim(), errors);
                if (rest.startsWith(")")) {
                    let [e, rest2] = parseQExpr(rest.substring(1).trim(), errors);
                    return [{ op: "all", v, e }, rest2];
                } else {
                    errors.push("Unclosed parentheses after ∀" + v);
                    return [null, rest];
                }
            } else if (s.startsWith("(∃")) {
                let [v, rest] = parseVar(s.substring(2).trim(), errors);
                if (rest.startsWith(")")) {
                    let [e, rest2] = parseQExpr(rest.substring(1).trim(), errors);
                    return [{ op: "exists", v, e }, rest2];
                } else {
                    errors.push("Unclosed parentheses after ∃" + v);
                    return [null, rest];
                }
            } else if (s.startsWith("not")) {
                let [e, rest] = parseQExpr(s.substring(3).trim(), errors);
                return [{ op: "not", e }, rest];
            } else if (s.startsWith("(")) {
                let [e, rest] = parseExpr(s.substring(1).trim(), errors);
                if (rest.startsWith(")")) {
                    return [e, rest.substring(1).trim()];
                } else {
                    errors.push("Unclosed parentheses");
                    return [null, rest];
                }
            } else {
                return parseTerm(s, errors);
            }
        }

        function parseTerm(s, errors) {
            // TODO handle predicate arguments, top, bottom
            return parseVar(s, errors);
        }

        function parseVar(s, errors) {
            let m = s.match(/^\w+/);
            if (m) {
                let v = m[0];
                let rest = s.substring(v.length).trim();
                if (v.endsWith("_") && rest.startsWith("(")) {
                    let m2 = rest.match(/\(\w*\)/);
                    if (m2) {
                        v = v + m2[0];
                        rest = s.substring(v.length).trim();
                    }
                }
                return [v, rest];
            } else {
                errors.push("Expected identifier: '" + s + "'");
                return ["", s];
            }
        }

        function paren(s, level, min) {
            if (level > min) {
                return "(" + s + ")";
            } else {
                return s;
            }
        }

        function render(e, level=0) {
            if (e.op) {
                switch (e.op) {
                    case "not":
                        return paren("\\lnot " + render(e.e, 3), level, 3);

                    case "implies":
                        return paren(render(e.e1, 1) + "\\rightarrow " + render(e.e2, 0), level, 0);

                    case "or":
                        return paren(render(e.e1, 1) + "\\lor " + render(e.e2, 2), level, 1);

                    case "and":
                        return paren(render(e.e1, 2) + "\\land " + render(e.e2, 3), level, 2);

                    case "all":
                        return paren("\\forall " + e.v + render(e.e, 4), level, 4);

                    case "exists":
                        return paren("\\exists " + e.v + render(e.e, 4), level, 4);
                }
            } else {
                return paren(e, level, 3);
            }
        }
    </script>
</body>

</html>